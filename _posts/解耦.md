---
title: 解耦
date: 2020-11-17 00:02:15
tags:
  - GoF
---
## 解耦为何如此重要？
软件设计与开发最重要的工作之一就是`应对复杂性`。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说**重构是保证代码质量不至于腐化到无可救药地步的有效手段**，那么利用解耦的方法对代码重构，就是**保证代码不至于复杂到无法控制的有效手段**。

实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它**能够在更高层次上提高代码的可读性和可维护性**。

除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那**代码整体的质量就不会差**。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以**聚焦于这个模块或者类，做相应的小型重构**。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。

## 代码是否需要解耦？
间接的衡量标准有很多，前面我们讲到了一些，比如，**看修改代码会不会牵一发而动全身**。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，**根据依赖关系图的复杂性来判断是否需要解耦重构**。

当然，这种判断还是有**比较强的主观色彩**，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。
<!--more-->

## 如何给代码解耦？
### 封装与抽象
封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以**有效地隐藏实现的复杂性，隔离实现的易变性**，给依赖的模块提供稳定且易用的抽象接口。

比如，Unix 系统提供的 open() 文件操作函数，我们用起来非常简单，但是底层实现却非常复杂，涉及权限控制、并发控制、物理存储等等。我们通过将其封装成一个抽象的 open() 函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中。除此之外，因为 open() 函数基于抽象而非具体的实现来定义，所以我们在**改动 open() 函数的底层实现的时候，并不需要改动依赖它的上层代码**，也符合我们前面提到的“高内聚、松耦合”代码的评判标准。

### 中间层
引入中间层能**简化模块或类之间的依赖关系**。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰：
![](https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/01.png)

除此之外，我们在进行重构的时候，**引入中间层可以起到过渡的作用**，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改：
1. 引入一个中间层，包裹老的接口，提供新的接口定义；
2. 新开发的代码依赖中间层提供的新接口；
3. 将依赖老接口的代码改为调用新接口；
4. 确保所有的代码都调用新接口之后，删除掉老的接口；

这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。**重构跟开发冲突的概率也变小了**。

### 模块化
模块化是**构建复杂系统常用的手段**。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。

实际上，模块化的思想无处不在，像 SOA、微服务、lib 库、系统内模块划分，甚至是类、函数的设计，都体现了模块化思想。如果追本溯源，**模块化思想更加本质的东西就是分而治之**。

### 其他设计思想和原则
“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则：
- 单一职责原则
内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而**实现高内聚的重要指导原则就是单一职责原则**。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了；
- 基于接口而非实现编程
  **通过接口这样一个中间层，隔离变化和具体的实现**。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于**将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）**；
- 依赖注入
依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以**让耦合关系没那么紧密，容易做到插拔替换**；
- 多用组合少用继承
继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，**利用组合来替换继承，也是一种解耦的有效手段**；
- 迪米特法则
迪米特法则讲的是，**不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口**。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合；

除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如`观察者模式`。
