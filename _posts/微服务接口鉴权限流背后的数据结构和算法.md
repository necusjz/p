---
title: 微服务接口鉴权限流背后的数据结构和算法
tags:
  - OpenSource
abbrlink: 2390158980
date: 2021-03-23 17:06:09
---
大应用拆分成微服务之后，服务之间的调用关系变得更复杂，平台的整体复杂熵升高，出错的概率、Debug 问题的难度都高了好几个数量级。所以，为了解决这些问题，服务治理便成了微服务的一个技术重点。所谓服务治理，简单点讲，就是管理微服务，保证平台整体正常、平稳地运行。服务治理涉及的内容比较多，比如**鉴权、限流、降级、熔断、监控告警**等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法。

## 鉴权背景介绍
假设我们有一个微服务叫用户服务（User Service）。它提供很多用户相关的接口，比如获取用户信息、注册、登录等，给公司内部的其他应用使用。但是，并不是公司内部所有应用，都可以访问这个用户服务，**也并不是每个有访问权限的应用，都可以访问用户服务的所有接口**：
![](https://raw.githubusercontent.com/necusjz/p/master/OpenSource/geek/09.png)

要实现接口鉴权功能，我们需要**事先将应用对接口的访问权限规则设置好**。当某个应用访问其中一个接口的时候，我们就可以拿应用的请求 URL，在规则中进行匹配。如果匹配成功，就说明允许访问；如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，我们就拒绝服务。
<!--more-->

## 如何实现快速鉴权？
接口的格式有很多，有类似 Dubbo 这样的 RPC 接口，也有类似 Spring Cloud 这样的 HTTP 接口，不同接口的鉴权实现方式是类似的。实际上，不同的规则和匹配模式，对应的数据结构和匹配算法也是不一样的。

### 如何实现精确匹配规则？
我们先来看最简单的一种匹配模式。只有当请求 URL 跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理:
![](https://raw.githubusercontent.com/necusjz/p/master/OpenSource/geek/10.png)

针对这种匹配模式，我们可以将每个应用对应的权限规则，存储在一个字符串数组中。当用户请求到来时，我们拿用户的请求 URL，在这个字符串数组中逐一匹配，匹配的算法就是 KMP、BM、BF 等。规则不会经常变动，所以，为了加快匹配速度，我们可以**按照字符串的大小给规则排序，把它组织成有序数组这种数据结构**。当要查找某个 URL 能否匹配其中某条规则的时候，我们可以采用`二分查找`算法，在有序数组中进行匹配。而二分查找算法的时间复杂度是 O(logn)（n 表示规则的个数），这比起时间复杂度是 O(n) 的顺序遍历快了很多。对于规则中接口长度比较长，并且鉴权功能调用量非常大的情况，这种优化方法带来的性能提升还是非常可观的。

### 如何实现前缀匹配规则？
我们再来看一种稍微复杂的匹配模式。只要某条规则可以匹配请求 URL 的前缀，我们就说这条规则能够跟这个请求 URL 匹配：
![](https://raw.githubusercontent.com/necusjz/p/master/OpenSource/geek/11.png)

Trie 树非常适合用来做前缀匹配。所以，针对这个需求，我们可以将每个用户的规则集合，组织成 `Trie 树`这种数据结构。不过，Trie 树中的**每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录**。因为规则并不会经常变动，所以，在 Trie 树中，我们可以把每个节点的子节点们，组织成有序数组这种数据结构。在匹配的过程中，我们可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点：
![](https://raw.githubusercontent.com/necusjz/p/master/OpenSource/geek/12.png)

### 如何实现模糊匹配规则？
如果我们的规则更加复杂，规则中包含通配符，比如“\*\*”表示匹配任意多个子目录，“\*”表示匹配任意一个子目录。只要用户请求 URL 可以跟某条规则模糊匹配，我们就说这条规则适用于这个请求：
![](https://raw.githubusercontent.com/necusjz/p/master/OpenSource/geek/13.png)

实际上，我们可以结合实际情况，挖掘出这样一个隐形的条件，那就是，并不是每条规则都包含通配符，包含通配符的只是少数。于是，我们可以**把不包含通配符的规则和包含通配符的规则分开处理**。我们把不包含通配符的规则，组织成有序数组或者 Trie 树（具体组织成什么结构，视具体的需求而定，是精确匹配，就组织成有序数组，是前缀匹配，就组织成 Trie 树），而这一部分匹配就会非常高效。剩下的是**少数包含通配符的规则，我们只要把它们简单存储在一个数组中**就可以了。尽管匹配起来会比较慢，但是毕竟这种规则比较少，所以这种方法也是可以接受的。当接收到一个请求 URL 之后，我们可以先在不包含通配符的有序数组或者 Trie 树中查找。如果能够匹配，就不需要继续在通配符规则中匹配了；如果不能匹配，就继续在通配符规则中查找匹配。

## 限流背景介绍
所谓限流，顾名思义，就是对接口调用的频率进行限制。比如每秒钟不能超过 100 次调用，超过之后，我们就拒绝服务。限流的原理听起来非常简单，但它在很多场景中，发挥着重要的作用。比如在秒杀、大促、双 11 等场景中，限流已经成为了保证系统平稳运行的一种标配的技术解决方案。按照不同的限流粒度，限流可以分为很多种类型。比如给每个接口限制不同的访问频率，或者给所有接口限制总的访问频率，又或者更细粒度地限制某个应用对某个接口的访问频率等等。

## 如何实现精准限流？
最简单的限流算法叫**固定时间窗口限流算法**。这种算法是如何工作的呢？首先我们需要选定一个时间起点，之后每当有接口请求到来，我们就将计数器加一。如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次访问请求），出现累加访问次数超过限流值的情况时，我们就拒绝后续的访问请求。当进入下一个时间窗口之后，计数器就清零重新计数：
![](https://raw.githubusercontent.com/necusjz/p/master/OpenSource/geek/14.png)

这种基于固定时间窗口的限流算法的缺点是，限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。假设我们的限流规则是，每秒钟不能超过 100 次接口请求。第一个 1s 时间窗口内，100 次接口请求都集中在最后 10ms 内。在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内。虽然两个时间窗口内流量都符合限流要求（<= 100 个请求），但在两个时间窗口临界的 20ms 内，会集中有 200 次接口请求。固定时间窗口限流算法并不能对这种情况做限制，所以，集中在这 20ms 内的 200 次请求就有可能压垮系统：
![](https://raw.githubusercontent.com/necusjz/p/master/OpenSource/geek/15.png)

为了解决这个问题，我们可以对固定时间窗口限流算法稍加改造。我们可以限制任意时间窗口（比如 1s）内，接口请求数都不能超过某个阈值（ 比如 100 次）。因此，相对于固定时间窗口限流算法，这个算法叫**滑动时间窗口限流算法**。流量经过滑动时间窗口限流算法整形之后，可以保证任意一个 1s 的时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑。我们假设限流的规则是，在任意 1s 内，接口的请求次数都不能大于 K 次。我们就维护一个大小为 K+1 的`循环队列`，用来记录 1s 内到来的请求。注意，这里循环队列的大小等于限流次数加一，因为**循环队列存储数据时会浪费一个存储单元**。

当有新的请求到来时，我们将与这个新请求的时间间隔超过 1s 的请求，从队列中删除。然后，我们再来看循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（tail 指针所指的位置）；如果没有，则说明这 1 秒内的请求次数已经超过了限流值 K，所以这个请求被拒绝服务：
![](https://raw.githubusercontent.com/necusjz/p/master/OpenSource/geek/16.png)

即便滑动时间窗口限流算法可以保证任意时间窗口内，接口请求次数都不会超过最大限流值，但是仍然不能防止，在细时间粒度上访问过于集中的问题。比如我刚刚举的那个例子，第一个 1s 的时间窗口内，100 次请求都集中在最后 10ms 中，也就是说，基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。实际上，针对这个问题，还有很多更加平滑的限流算法，比如`令牌桶算法`、`漏桶算法`等。
